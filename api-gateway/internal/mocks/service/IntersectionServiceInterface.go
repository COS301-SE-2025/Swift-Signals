// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	model "github.com/COS301-SE-2025/Swift-Signals/api-gateway/internal/model"
	mock "github.com/stretchr/testify/mock"
)

// MockIntersectionServiceInterface is an autogenerated mock type for the IntersectionServiceInterface type
type MockIntersectionServiceInterface struct {
	mock.Mock
}

type MockIntersectionServiceInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockIntersectionServiceInterface) EXPECT() *MockIntersectionServiceInterface_Expecter {
	return &MockIntersectionServiceInterface_Expecter{mock: &_m.Mock}
}

// CreateIntersection provides a mock function with given fields: ctx, req
func (_m *MockIntersectionServiceInterface) CreateIntersection(ctx context.Context, req model.CreateIntersectionRequest) (model.CreateIntersectionResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for CreateIntersection")
	}

	var r0 model.CreateIntersectionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, model.CreateIntersectionRequest) (model.CreateIntersectionResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, model.CreateIntersectionRequest) model.CreateIntersectionResponse); ok {
		r0 = rf(ctx, req)
	} else {
		r0 = ret.Get(0).(model.CreateIntersectionResponse)
	}

	if rf, ok := ret.Get(1).(func(context.Context, model.CreateIntersectionRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIntersectionServiceInterface_CreateIntersection_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateIntersection'
type MockIntersectionServiceInterface_CreateIntersection_Call struct {
	*mock.Call
}

// CreateIntersection is a helper method to define mock.On call
//   - ctx context.Context
//   - req model.CreateIntersectionRequest
func (_e *MockIntersectionServiceInterface_Expecter) CreateIntersection(ctx interface{}, req interface{}) *MockIntersectionServiceInterface_CreateIntersection_Call {
	return &MockIntersectionServiceInterface_CreateIntersection_Call{Call: _e.mock.On("CreateIntersection", ctx, req)}
}

func (_c *MockIntersectionServiceInterface_CreateIntersection_Call) Run(run func(ctx context.Context, req model.CreateIntersectionRequest)) *MockIntersectionServiceInterface_CreateIntersection_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(model.CreateIntersectionRequest))
	})
	return _c
}

func (_c *MockIntersectionServiceInterface_CreateIntersection_Call) Return(_a0 model.CreateIntersectionResponse, _a1 error) *MockIntersectionServiceInterface_CreateIntersection_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIntersectionServiceInterface_CreateIntersection_Call) RunAndReturn(run func(context.Context, model.CreateIntersectionRequest) (model.CreateIntersectionResponse, error)) *MockIntersectionServiceInterface_CreateIntersection_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllIntersections provides a mock function with given fields: ctx
func (_m *MockIntersectionServiceInterface) GetAllIntersections(ctx context.Context) (model.Intersections, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllIntersections")
	}

	var r0 model.Intersections
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (model.Intersections, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) model.Intersections); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(model.Intersections)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIntersectionServiceInterface_GetAllIntersections_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllIntersections'
type MockIntersectionServiceInterface_GetAllIntersections_Call struct {
	*mock.Call
}

// GetAllIntersections is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockIntersectionServiceInterface_Expecter) GetAllIntersections(ctx interface{}) *MockIntersectionServiceInterface_GetAllIntersections_Call {
	return &MockIntersectionServiceInterface_GetAllIntersections_Call{Call: _e.mock.On("GetAllIntersections", ctx)}
}

func (_c *MockIntersectionServiceInterface_GetAllIntersections_Call) Run(run func(ctx context.Context)) *MockIntersectionServiceInterface_GetAllIntersections_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockIntersectionServiceInterface_GetAllIntersections_Call) Return(_a0 model.Intersections, _a1 error) *MockIntersectionServiceInterface_GetAllIntersections_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIntersectionServiceInterface_GetAllIntersections_Call) RunAndReturn(run func(context.Context) (model.Intersections, error)) *MockIntersectionServiceInterface_GetAllIntersections_Call {
	_c.Call.Return(run)
	return _c
}

// GetIntersectionByID provides a mock function with given fields: ctx, id
func (_m *MockIntersectionServiceInterface) GetIntersectionByID(ctx context.Context, id string) (model.Intersection, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetIntersectionByID")
	}

	var r0 model.Intersection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (model.Intersection, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) model.Intersection); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(model.Intersection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIntersectionServiceInterface_GetIntersectionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetIntersectionByID'
type MockIntersectionServiceInterface_GetIntersectionByID_Call struct {
	*mock.Call
}

// GetIntersectionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
func (_e *MockIntersectionServiceInterface_Expecter) GetIntersectionByID(ctx interface{}, id interface{}) *MockIntersectionServiceInterface_GetIntersectionByID_Call {
	return &MockIntersectionServiceInterface_GetIntersectionByID_Call{Call: _e.mock.On("GetIntersectionByID", ctx, id)}
}

func (_c *MockIntersectionServiceInterface_GetIntersectionByID_Call) Run(run func(ctx context.Context, id string)) *MockIntersectionServiceInterface_GetIntersectionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockIntersectionServiceInterface_GetIntersectionByID_Call) Return(_a0 model.Intersection, _a1 error) *MockIntersectionServiceInterface_GetIntersectionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIntersectionServiceInterface_GetIntersectionByID_Call) RunAndReturn(run func(context.Context, string) (model.Intersection, error)) *MockIntersectionServiceInterface_GetIntersectionByID_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateIntersectionByID provides a mock function with given fields: ctx, id, req
func (_m *MockIntersectionServiceInterface) UpdateIntersectionByID(ctx context.Context, id string, req model.UpdateIntersectionRequest) (model.Intersection, error) {
	ret := _m.Called(ctx, id, req)

	if len(ret) == 0 {
		panic("no return value specified for UpdateIntersectionByID")
	}

	var r0 model.Intersection
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, model.UpdateIntersectionRequest) (model.Intersection, error)); ok {
		return rf(ctx, id, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, model.UpdateIntersectionRequest) model.Intersection); ok {
		r0 = rf(ctx, id, req)
	} else {
		r0 = ret.Get(0).(model.Intersection)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, model.UpdateIntersectionRequest) error); ok {
		r1 = rf(ctx, id, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockIntersectionServiceInterface_UpdateIntersectionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateIntersectionByID'
type MockIntersectionServiceInterface_UpdateIntersectionByID_Call struct {
	*mock.Call
}

// UpdateIntersectionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id string
//   - req model.UpdateIntersectionRequest
func (_e *MockIntersectionServiceInterface_Expecter) UpdateIntersectionByID(ctx interface{}, id interface{}, req interface{}) *MockIntersectionServiceInterface_UpdateIntersectionByID_Call {
	return &MockIntersectionServiceInterface_UpdateIntersectionByID_Call{Call: _e.mock.On("UpdateIntersectionByID", ctx, id, req)}
}

func (_c *MockIntersectionServiceInterface_UpdateIntersectionByID_Call) Run(run func(ctx context.Context, id string, req model.UpdateIntersectionRequest)) *MockIntersectionServiceInterface_UpdateIntersectionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(model.UpdateIntersectionRequest))
	})
	return _c
}

func (_c *MockIntersectionServiceInterface_UpdateIntersectionByID_Call) Return(_a0 model.Intersection, _a1 error) *MockIntersectionServiceInterface_UpdateIntersectionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockIntersectionServiceInterface_UpdateIntersectionByID_Call) RunAndReturn(run func(context.Context, string, model.UpdateIntersectionRequest) (model.Intersection, error)) *MockIntersectionServiceInterface_UpdateIntersectionByID_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockIntersectionServiceInterface creates a new instance of MockIntersectionServiceInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockIntersectionServiceInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockIntersectionServiceInterface {
	mock := &MockIntersectionServiceInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
